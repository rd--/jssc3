# 0.4 The Most Important Objects and Messages in SC2

80 percent of the SC2 code you will encounter will be one of the things covered here, so this is the basic vocabulary in SC2. Getting a good understanding of this material right away will make working with SC2 a lot easier and more fun.

(Feel free to print this out as a reference sheet.)

## UGen

Unit Generators create audio or control rate signals.

Some audio rate Unit Generators:

- SinOsc, Saw, Pulse -- waveform generators
- WhiteNoise, PinkNoise, GrayNoise -- random/noise generators
- RLPF, OnePole, Resonz -- filters
- DelayN, CombL -- delqay lines
- EnvGen -- control function generators

They make or modify audible signals.  You create new instances of them with the message .ar, so anything that understands the message .ar is an audio rate Unit Generator (a.k.a. UGen).

_SinOsc.ar_ (object creation message (instance creation, constructor, factory method) generates a new audio rate sine oscillator Ugen.

Some control rate Unit Generators:

- MouseX, MouseY -- track user I/O in a control-rate signal
- Line, XLine -- ramp interpolators
- SinOsc, LFPulse, EnvGen -- control (LFO) generators

They make signals that control some parameters of other (audio or control) signals. You create them with message .kr, so anything that understands the message.kr is an control rate unit generator (a.k.a. UGen).  Some Ugens, e.g. SinOsc, EnvGen, can be created in both ar and kr versions.

_MouseX.kr_ generates a new control rate generator that tracks the x position of the mouse.

While .ar signals are calculated for every sample, typically 44100 times per second, kr signals are calculated less often, e.g. every 64th sample; the samples in between are interpolated.  This is much more efficient and precise enough for signals that change only slowly.

## Synth

Synth is the Class that handles the real-time signal generation.

It understands several useful messages:

- .play			tells Synth to generate just the sound.
- .scope		tells Synth to generate the sound and show it in an oscilloscope window onscreen.
- .plot			calculates the signal for a period of time and displays it onscreen.
- .record		generates the sound and records it to a file.
- .fftScope		tells Synth to generate the sound and show the sound's frequency spectrum	in an oscilloscope window onscreen.
- .dualScope		tells Synth to generate the sound, and display	both its waveform and its frequency spectrum.

This will be loud! So turn down volume first.

    Synth.play({ SinOsc.ar });
    Synth.scope({ SinOsc.ar });
    Synth.record({ Pulse.ar }, 2, "RecordPulseTest"); // duration to record, and filename.
    Synth.plot({ Saw.ar });
    Synth.fftScope({ BrownNoise.ar });

Note the recorded soundfile will be in the SC2 folder.

Note also that the FFT display is mirror-imaged! (This is because FFT analysis math works this way in order to be reversible with IFFT, not to look "natural" to understand right away.)

Using a control rate UGen to change a frequency:

    // mouse controls frequency of the sine
    SinOsc(freq: MouseX(minval: 100, maxval: 1000, warp: 0, lag: 0.2),phase: 0) * 0.1

## Function

Functions are objects that store code for later execution.

Lines of code between braces { } make a Function.  A Function can be executed as often as necessary.

E.g. make a function that generates a random number, and evaluate it three times:

    f = { 20.0.rand };
    f.value.postln;
    f.value.postln;
    f.value.postln;

Make a function that creates a Ugen first, then use the function as an argument for Synth.play:

    f = { FSinOsc.ar(220, 0.1) };
    Synth.play(f);

## Array

Collections and Arrays are groups of objects.

Square brackets tie several objects together; usually in order to do the same thing with each of the items in the Collection.

An Array is the simplest kind of Collection.

    [ 1, 2, 3, 4 ];

Do the same thing with each item in the Array:

    [ 1, 2, 3, 4 ].do({ arg each; each.squared.postln });

Like .do, but collect the results in a new Array:

    [ 1, 2, 3, 4 ].collect({ arg each; each.sqrt }).postln;

Randomize the order of the elements:

    [ 1, 2, 3, 4 ].scramble.postln;

Reverse ...

    [ 1, 2, 3, 4 ].reverse.postln;

Copy a segment into a new Array:

    [ 1, 2, 3, 4 ].copyRange(1, 2).postln;

Access individual elements by their index:

    [ 1, 2, 3, 4 ].at(0).postln;
    [ 1, 2, 3, 4 ].at(3).postln;

Put a new element into the Array at index 2:

    [ 1, 2, 3, 4 ].put(2, 789).postln;

Arrays are also used to create multiple audio channels.  Synth plays every item in the Array as one channel. It must be a UGen (or patch of several UGens) of course!

    [FSinOsc(220, 0), Saw(330), PinkNoise()] * 0.1

# Spawn

Spawn, TSpawn, Voicer (OverlapTexture, XFadeTexture, ...) all can create new UGens while Synth is running.

New Event function runs every time Spawn triggers, and generate a short grain of sound which ends by itself:

    Spawn.ar({
    		PSinGrain.ar(200 + 1800.0.rand, 0.1, 0.2);
    	}, nextTime: 0.5)}

## Env, EnvGen

Envelopes are used to make control signals that change over time.  When used for amplitude, they also serve to remove UGens that are not needed anymore.


    var env = Env.triangle(dur: 0.2, level: 0.1);
    Spawn.ar({
    	"Now!".postcln;
    	Saw.ar(100 + 300.rand) * EnvGen.kr(env);
    }, nextTime: 0.5)

## .post, .postln

Every object understands post and postln to mean: print a simple description of what it is into the current text window.

Try that with any object you like to see what SC2 tells you about it.  This is usually very helpful information.

    { FSinOsc.ar(220, 0.1) }.postln;
    (23 * 45 + 67).postln;
