# 1.1 Survival in the SuperCollider 2 Environment

SuperCollider2 is both a programming environment and a language.  The environment is designed to let you work really fast and efficiently; and for everything you need to do often, there is a way to get it done quickly.

This section shows you how to use the text editor to execute program code for testing, move around in the environment with ease, and find out what a given piece of code does.

The Survival Shortcuts:

1. Double-clicking right on a delimiter (parenthesis, brace, or bracket) selects the content between this delimiter and its match.  (I know you know by now, but it's here for completeness.)

    { FSinOsc(500, 0) * 0.1 }.play

You can also select text by hand as you would expect, e.g. by dragging over it inside a line or over several lines.

2. Pressing the enter key executes (= evaluates) the selected code.

Note: only 'enter' (usually at the number block) does this, 'return' is NOT identical with enter.  You can also use Evaluate Selection from the Lang menu.

    (2 + 3).postln; // adds 2 + 3 and posts the result

You can open a new window (Command-N) and while it is in front, Choose Lang -> Post Here Always (Command-7) to keep all your posted results separate from your code.

3. Command-Z undoes the last action.

So if that action was printing the result of 2+3, you can remove the posted line easily with Command-Z.

(Note: longer results may have been posted in several sections, so Command-Z will only remove the last section; but SC2 puts the cursor after the last new line, so if you shift-click at the beginning of the posted text, you select the whole thing and can get rid of it at once with the delete key.)

4. Command-. (period) stops the execution of whatever is running.  Select this, then execute it with 'enter':

	{ WhiteNoise() * 0.1 }.play

This starts playing a noise generator.  I assume you'll be glad to know how to stop it again.

Another possible emergency measure to remember: Command-8 cuts the volume by 60 dB.

5. Command-P evaluates the selected code and prints the result.

For debugging, this is very handy. Are you getting the results you want?  It also saves you typing .postln millions of times when you just want to check whether some piece of code really does what you wanted.

Select and Command-P (print) this:

    ( 2 + 3 )

or select and execute this:

    ( 2 + 3 ).postln

6. Command-H opens the help file for any Class.

You can get help and useful background information really fast by selecting a Class (i.e. nearly anything that starts with an uppercase, e.g. Synth, SinOsc, DelayN ...), by double-clicking somewhere inside the word to select it, and then typing Command-H. This brings up a help window with precise documentation and simple examples.  Try it with the Classes in here:

    { PinkNoise() * Ln(0.2, 0, 10) }.play

If you are looking for a specific word in the help file, such as the message 'play', (to look up how that message is meant to be used), press Command-F to activate the find function.  Note that the Color Menu has an entry Syntax Colorize: this assigns specific colors to specific objects in the code, e.g. Classes become blue, Comments red, etc.

7. Command-Y tells you who understands a Message, and what arguments the method usually expects.

E.g. somewhere you see the code line

    [1,2,3].reverse;

select it and print the result: it should be [ 3, 2, 1 ].  now select the message reverse and type Command-Y to see who understands it: A new window opens and lists all the Classes that do.

- Array::reverse :   this.reverse()
- ArrayedCollection::reverse :   this.reverse()
- List::reverse :   this.reverse()
- Signal::reverse :   this.reverse(beginSamp, endSamp)

Which of these Classes does [1,2,3] belong to so that it understands reverse?  That is very easy to find out, you can ask any object what its class is.  Just print (Command-P) this:

    [1,2,3].class;

In this case, [1,2,3] is an array, and the method expects no further arguments (empty parentheses).  Classes, messages, arguments etc. are explained in more detail very soon.)

More examples:

    2.squared.postln;
    1.5.max(2.1).postln;

- What are the messages here?
- What are the objects?
- Which classes do the objects belong to?
- How can you learn about these classes and what they do?
- Which message in this example takes an argument?
- What kind of object will that argument most likely be?

Can you find all the answers? It should be possible with the shortcuts covered here.

Next: Go to [Help] (you don't need to select it, just Command-H will take you there too) and browse through all the items under Intro and The Program, just so you have seen them once.

8. Two more shortcuts for the Curious and/or Courageous:

a. The message '.inspect' shows you what's inside any object.  Try some:

    12.5.inspect
    [1,2,3,4].inspect
    FSinOsc(220, 0).inspect

b. selecting a Class and typing Command-J opens the source code file for that Class.

If you want to look up how exactly an Object does something, you can probably look it up here; many of the methods (the things objects do when they receive a message with that name) are written in SC2 code.  You can find the method quickly by selecting the Class and message, as it is printed when you look up a method with command-Y. E.g. selecting

    Array::reverse

will take you right to the source code for that method.  Don't worry, there is no need to understand all the methods right away.

See the SC doc file [Internal Snooping] and the file language examples in the Examples folder for more on this.

If you are clear on all of this, you may pass Go, collect 200, and look up James McCartney's definitions of the OOP vocabulary: [00 Intro to Objects].

Then (or directly, if Intro is too abstract) proceed to [1.2 Dangerously Simplified OOP].
