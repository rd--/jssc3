# 1.2 Object Oriented Programming Basics

In order to use the power and flexibility of SC2, you need a good grasp of OOP.  This section is a simple introduction to the most important concepts of OOP.  You will also learn the syntactical conventions that SuperCollider uses.

See also [00 Intro to Objects] and my [0.6 Other References] page for more detailed background.

## Why bother with OOP? What's so great about it?

SuperCollider 2 is a fully object-oriented programming language and environment, and a lot of its power comes from this approach. The OOP literature usually gives these aims for designing a programming language according to the OO paradigm:

A good programming language should be

1. reasonably natural to understand for human beings,

2. powerful and expressive, i.e. it should be easy to put little things together to make bigger ones, and thus to write short programs that create very complex results,

3. manageable and flexible, i.e. even complex programs (including very fundamental elements of the language itself!) can still be understood and even drastically changed by people other than the original author.

## What is an Object?

An Object contains data and knows a few (or a lot of) things to do with them.  All a programmer does is tell the object which of these things to do: Make a new object, evaluate it, change its data, remove it, etc.

E.g. make a new object that is a list (use Command-P to print it):

    Set.new; // This returns an new (and empty) Set

Very many objects are created with shorter syntax:

    []

or

    [5,6,7]

creates an array directly without explicitly using .new.  Some more examples, e.g. create a new Function:

    {}

A new Envelope:

    Env([0, 1, 0], [1, 1], [-4], nil, nil, 0)

A new Integer (one kind of number, which also is an object!):

    12

There are two ways to verify what object an expression generates:

    12.class // and
    12.inspect
    (12 / 5.2).postln;
    (12 / 5.2).class;

Inspecting more complex objects may tell you a lot more than you want to know:

    Array.inspect

You can safely ignore this for now, and just read what looks intelligible to you.  One central concept of OOP, Encapsulation, holds that you only need to know what messages an Object understands, its Interface, to tell the object what to do, and to leave the details (the "How") to the Object itself.

In a system that features Encapsulation, you can actually change the internals of any given method completely (e.g. for more efficiency) without breaking any existing code! All you need to do is keep the interface the same, and all the existing code that uses this method will still work.  (More about Objects below in Classes and Instances and State and Behavior.)

## What Is A Message?

A message tells an Object what to do.  This makes the Object the Receiver of that Message.

Messages always begin with a lowercase, and (following the Smalltalk convention) compound words have embedded uppercases at each new word, e.g. asPoint, sampleRate, removeAllSuchThat etc.  By convention, you are required to put a dot between an object and a message you are sending to it; e.g. Sc.play, 12.inspect, etc. etc.

E.g. sending the object 12 the message .inspect tells that object to inspect its contents.  Sending the object 9 the message .sqrt tells it to return the square root (probably 3!, unless you set it differently).

    9.sqrt

## What happens if you chain messages? Who receives the second message?

Try it by comparing these three lines:

    9.sqrt.postln;
    (9.sqrt).postln;
    9.postln;

9.sqrt tells 9 to return something it knows the answer to, sqrt, which is a number, and then that number gets printed.

One more example with a longer chain of messages:

    [ -25, -9, 16 ].abs.sqrt.sorted

Try going through each step by printing it separately.

### Different Kinds of Messages: Unary and Binary

All the examples so far had only receivers and messages, but no arguments; these messages are called unary, since they involve only one object.

Some messages only make sense with two Objects; they are called (no surprise:) binary, and the simplest example is

    3 + 4 	// print this.

Here, the Integer Object with the value 3 gets sent the message '+' and the argument 4, which is also an object.

## In what order does SC2 execute messages?

Always from left to right, unless you change the order with parentheses.  Try this:

    2 * 3 + 4 * 5;

in math class you probably learned that the correct order is

    (2 * 3) + (4 * 5);

but of course, SC (and you!) would have agree on the precedence for all kinds of functions like exponentials, sines, rounding etc, so it is really a lot easier to just go left to right, and use lots of parentheses to document your intentions as clearly as possible.

The only other rule: Unaries before Binaries!

This makes good sense, e.g. you would expect

    3.log + 4.log			// (log is natural logarithm)

to be

    (3.log) + (4.log)

and not

    ((3.log) + 4).log

see the doc file [02 Method Calls] for more on Messages.

## How do you 'make' new Objects? Classes and Instances

The Integer Objects 12 and 15 are obviously both integers, but they are not the same Object, as they have different values; they are objects of the same Class.

A Class is an Object that knows how to make new Objects of its kind.  If you will, a Class is a factory for making new objects.  It also knows all the messages that Objects of its kind (in OOP-speak: instances of that class) will understand.

A real world example: All human beings are different instances (individuals) of the Class HumanBeing.

All the Classes in SC2 are actually created as Objects in SC2's memory space when the program is started, and they remain in memory all the time. SC2 finds the source code in the folder called DefaultLibrary and then compiles all of them into memory objects, in case you wondered. That is what part of the text in the startup window means:

````
...
compiling class library..
   NumPrimitives = 413
pass 1 done
   Method Table Size 755304 bytes
   Number of Method Selectors 1219
   Number of Classes 740
   Number of Symbols 3315
   Byte Code Size 42495
   compiled 91 files in 1.27 seconds
...
````

When you tell a Class to make a new Object of its kind, then this newly created Object is called an instance of this Class.

This is a very important distinction, and a common source of errors!

Every human being has indivdual properties like gender, age, eye color and so on.  So asking any specific human for these properties makes good sense; however if you try asking the Class HumanBeing itself, i.e. the abstract concept that all human beings have in common, you will not get a valid answer!

E.g. if you tell the Object Set (which is the Class Set) to make a new Object of its kind, the resulting Object will be an instance of Set, or simply a set.

    var aSet;				// declare a variable for this program, named aSet
    aSet = Set.new;			// make an instance of the class "Set"
    aSet.addAll([1,2,3]);		// add some elements to the Set,
    aSet.inspect;			// inspect the Object "aSet".

Try comparing inspect of the class Set with a inspect of a Set instance:

    Set.inspect;

The Class gets inspected as an instance of its meta class.

This is SC's internal way of naming Classes; the only important thing here is that anything that inspects as Instance of a meta class is the Class itself, not an Instance of the Class.

    Set([6,7,8]).inspect;

An instance of a Set gets inspected very differently.

## What's inside an Object? State and Behavior

Any Object has instance variables that contain that Object's data.

For example, a Point contains two instance variables:

    Point(3, 4).inspect

named (not surprisingly) x and y.  All the current values in these instance variables make up the Object's State.

The Class Point lets you access x and y directly, because it was programmed to allow for that, and because it makes sense to be able to change them from outside. Many other classes do not let you access their instance variables directly; instead you can only change them indirectly by using the messages the object understands. This is called the Behavior of that Class.  This concept makes it possible to change the inner workings of an object X completely (e.g. for improved efficiency) without having to also change all the other objects that use that object X! This principle of separating State and Behavior of Objects is called Encapsulation.

This is probably enough for now; you will see a lot of these terms and some new ones that also belong to the OOP terminology in the next few tutorial files. The concepts will become much clearer when you begin to work with them in your own code.  If you would like to read more OOP theory now, see also the doc files [00 Intro to Objects] and the other windows [Help] has under The Language, or check out some of the literature in the [References].

Next: [1.3 First Steps In OOP Terms].
