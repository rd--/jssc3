# 1.4 Positional or Keyword Style

This section looks at the different ways SC handles messages.  You can choose any style you like, but in order to understand existing code, it helps to know the others too.

This is the same program as in the previous file without comments:

    Sc.play({ FSinOsc(220, 0) * 0.1 })

Note that the order of arguments is essential. This way of giving arguments to a function is called positional.  The help file for any class tells you the order of arguments for any (documented) method, e.g. FSinOsc tells you that the arguments for method ar are:

> FSinOsc.ar(freq, iphase, mul, add)

I.e. the oscillator frequency, a multiplier for the amplitude value, and an offset (or an input for another signal).  Look what happens if you leave out the arguments: (Turn the volume lower before executing this!)

    Synth.play({ FSinOsc.ar })
    Synth.play({ FSinOsc.ar(440) })
    Synth.play({ FSinOsc.ar(440, 1) })

freq defaults to 440 and mul to 1. Default values always try to give you a sensible result even if you provide no arguments. (You would not hear a tone with freq = 5 Hz or mul (amplitude) = 0).

While positional arguments are somewhat faster in execution, they have drawbacks: If you do not need argument number 2, but you do need argument 3, you have to remember to put a 'blank' argument with a harmless value in position 2.  E.g. the Class SinOsc has a different argument list order than FSinOsc (look it up!):

    Synth.scope({ SinOsc.ar(440, 0.1) })	// this does not work as you may have expected!

What you need to do here is to know the default and write it in:

````
Sc.play({
	SinOsc(440, // freq,
			0 // zero phase offset,
	) * 0.1 // then mul.
})
````

If you use methods with six or more arguments, it can be annoying to have to count them, and to look them up; and if you look at the code to check for errors (to debug), you have to look it up and count again.  Besides, it creates the impression of being important, when it acually is not.  (Why is that 0 here? Oh, it's only the blank phase input.)

This is why Smalltalk (SC2's ancestor language) always uses keyword arguments; and SC2 lets you write in a similar style as an option:

````
Sc.play({
	FSinOsc(
		freq: 220,
		iphase: 0
	) * 0.1
})
````

Note that the arguments can be in any order!

    FSinOsc.ar( mul: 0.2,freq: 220 )  	// is fully equivalent to
    FSinOsc.ar( freq: 220, mul: 0.2 )


I actually prefer this style with a separate method name and keyword-able argument list to traditional Smalltalk; in most Smalltalk dialects the sequence of keywords would already be the method name, and there would be different methods for each likely order of keywords that users might use. Here's some pseudo-Smalltalk to show that:

    FSinOsc freq: 220;
    FSinOsc freq: 220 mul: 0.1;
    FSinOsc mul: 0.1 freq: 220;

    FSinOsc freq: 220 mul: 0.1 phase: 1.57;
    FSinOsc freq: 220 phase: 1.57 mul: 0.1;

These five lines would already necessitate five different methods that do the exact same thing.  For e.g. five arguments, there are much more permutations; consider that you can leave out arguments to have them default too.)

Knowing this, you can actually write the exact same code for SinOsc too:

````
(
Synth.play(
	{ SinOsc.ar(
		freq: 220, 	// no phase argument needed anymore,
		mul: 0.2) 	// and no need for per-argument doc...
	}
	)
)
````

Note how much closer to natural language this is; since you will need less comments this way, this quality of code is called self-documenting.  You can overdo that too, of course, so it is nice to have a choice:

````
(
Synth.play(
	duration: 3,
	ugenGraphFunc:	// this is what the first argument to Synth.play is called.
		{
			FSinOsc.ar(
				freq: 220,
				mul: 0.2
			)
		}
	)
)
````

There is no need to be religious about one style or the other; just use what makes life easier for everybody who will read your code.  So if you need the absolute maximum performance you can get, write your code with positional arguments. If your top priority is fast and clear programming work, use keywords. (You can always write a speed optimized version later if necessary.)

## Terseness vs. natural language

SuperCollider allows for many shorthands to often used things.  We need to take a little detour for explanation.  Create an oscillator object inside a Function object.  The Function also understands the message play.

````
var aFunction = { FSinOsc(220, 0) * 0.1 };
aFunction.play
````

You can look this up in the Function.sc source code file. See also [6.4 Writing New Methods].

By not naming the function you can write the same thing really terse:

    { FSinOsc(220, 0) * 0.1 }.play

Another example for terseness is Ugen creation with .ar and .kr: Since UGens will always be used a lot, having to type .audioRate, or even more verbose .newAtAudioRate every time would be irritating.

Next: [1.5 Basic SC Syntax].
