# 2.2 Sounds As Functions

Functions are a fundamental notion in almost every programming language, and in SC2 as well. This section gives you a general idea of the various things functions can be used for. If you have some programming experience in other languages, you will notice that Functions are somewhat different in an object-oriented system like SC2.

As you have seen, the first arg to Synth.play is called ugenGraphFunc; technically speaking, this is a Function object.

Look into a Function, writing a piece of code inside of { } creates a new Function.

    var myFunction = { };
    myFunction.inspect;

Here is a function that actually can do something:

    f = { arg a; a.postln }; 	// how useful is this function ?
    f.value("someMessage")

An example of a Function with comments.  Define a new Function that take two arguments, called a and b,.  Define a temporary variable I will use inside this Function.  Add my two args, and assign the sum to the variable and print the result.  _aFunction.value_ tells aFunction to actually execute the code in its definition.  This example takes an argument list with the arguments 4 and 5.  (Doing this is known as "calling the function".)

````
var sumAndPostTwoArgs = { // begin a function definition
	arg a, b; // with two arguments
	var result; // and a temporary variable
	result = a + b;	// assign sum to result
	result.postln // print result.
}; // end function definition
sumAndPostTwoArgs.value(4, 5) // call the function
````

Same function, less text:

````
var postSum = {
	arg a, b;
	(a + b).postln
};
postSum.value(6, 7)
````

You may not always want to supply all the arguments when you call a function: SC2 lets you define what argument values a function will assume by default, i.e.  when no values are given.

Same as above, with defaults:

````
var postSum;
postSum = { arg a = 2, b = 1;
		 (a + b).postln };
postSum.value(6, 7); 		// test cases: give two args,
postSum.value(6); 			// give one arg,
postSum.value; 			// no arg.
````

Watch what happens without defaults:

````
var postSum;
postSum = { arg a, b; (a + b).postln };
postSum.value(6, 7); 			// test cases: give it two args, and it runs fine;
postSum.value(6); 			// give it one arg only, and you get an error.
//	postSum.value; 			// try no arg too if you like.
````

The notion of default arguments also applies to methods; in fact, we have used them all along.

````
{
	Saw.ar  	// Saw.ar would expect arguments freq, mul, add.
}.scope;		// scope would expect an argument duration.
````

You can check what they default to by looking up the *ar method in Saw's source code file: select [Saw], and do Command-j:

````
Saw : UGen {
	*ar { arg freq=440.0, mul = 1.0, add = 0.0;
	etc etc...
````

Too many arguments are simply ignored:

````
var postSum;
postSum = { arg a, b; (a + b).postln };
postSum.value(6, 7, 8); 	// a simple test case.
````

And the most important thing about functions: The last statement of a function produces the result of the function; this is the value that the function returns.  As this is what you expect to come back when you call the function, errors here can be drastic.

Some examples:

````
{ 	a = (2 + 3);
	BrownNoise.ar(0.1) }.value		// print this,

{ BrownNoise.ar(0.1);
	a = (2 + 3);  }.value 			// then print this.
````

The statements in both functions are the same, and the objects generated
are the same, but the result of the function is very different!

    { var a; a = (2 + 3); BrownNoise() * 0.1 }.play // execute this, and it runs.
    { var a; BrownNoise() * 0.1; a = (2 + 3) }.play // execute this, and it fails

Now that you know what functions do, look up what the first argument to Synth.play is. It is called ugenGraphFunc, and it is precisely that: A Function that returns a Graph of Ugens for Synth to play.  We can actually define that Function BEFORE writing Synth.play:

````
(
var soundFunction;
soundFunction = {
	arg freq = 500, 		// arguments to the function
	amp = 0.2,
	dur = 2;
	var env; 			// an envelope to be used inside the function
						// make an envelope with the params:
	env = Env.linen(0.01, 	// attack time,
		0.49, 			// sustain time
		0.5, 			// decay time, 	(attack + sustain + decay time = 1...)
		1);			// level (normalized to 1).
	// This is the last statement in the Function; so its result will be returned:
	EnvGen.ar(env, 		// An Envelope generator UGen, with an envelope,
		FSinOsc.ar(freq), // a sine oscillator as input,
		0, 			 // add no offset, (this empty var is necessary because of positional
					// arguments in functions - unless you use keywords!)
		amp, 			// scale the env to the amplitude that was given as an argument,
		0, 			// add no level bias,
		dur) 			// scale the duration of env to the duration given as an argument.
};					// try printing or inspecting just the Function.
					// Now play the sound with it's default parameters:
Synth.play( { soundFunction.value } );
					// pass arguments to the soundFunction:
					// (comment out previous line, uncomment the next line.)
//	Synth.play({ soundFunction.value(220, 0.1, 1) } );
)
````

Move on to Synthesis methods next: [2.5 Subtractive Synthesis] or [2.4 Modulation Synthesis].
