# 2.3 More Synthesis Basics: Envelopes, Spawning, and Playing Scores

Building little synth patches is very easy in SC2. However, to stop and start sounds, or to generate a sequence of sound events, you need to meet Env and Spawn.

You will have seen and heard this one too often by now:

    Synth.play( { FSinOsc.ar(440, 0.1) } )

and you may want to know how you can play a sequence of several notes.  For that, you need something that stops (and also shapes) the first sound: an Envelope, and something that can start the next sound: a Spawn object.

Envelopes are created with the Env class (see the help file for that Class...)  These are the two simplest methods to create an Env:

- *triangle(duration, level)
- *sine(duration, level)

(Note: the * before a method means it is a class method, i.e.  the message that calls this method goes to the Class, not an instance.  A message to make a new instance can obviously only go to a Class.)

    Env.triangle(dur: 1, level: 1).plot;

Step by step:

````
Env.triangle(		// create a triangle-shaped envelope with two arguments:
	dur: 1,		// a total duration of 1 second,
	level: 1		// and going up to a maximum level of 1.
).plot;				// plot this new envelope (an instance of Env) in a window.
````

Note that the method triangle knows that this kind of envelope starts and ends with zero; it need not be told (and in fact cannot be told otherwise).

There are many other methods to create envelopes, see the Env help file.

Envelopes also have a convenience method called .test; guess what that does, then see if you were right:

````
Env.triangle(2, 0.5).test;

Env.sine(2, 0.5).plot; 		// Note: the sine method is sent to the Env object,
					// which causes the Env to have a sine shape; it does
					// not specify the waveform that Env uses for testing!
````

So how can we 'wrap' or plug our sine oscillator into that envelope?  First we need a UGen that creates a signal from this envelope (an Env instance is only a description of that envelope, it is not a UGen by itself!), then we need to combine that signal with the sine osc signal.  This is handled by the Envelope Generator, a Class called EnvGen.

````
e = Env.perc(					// create the envelope first, this time
	attack: 0.01, 				//  with a different method. (look it up!)
	release: 1,
	level: 1,
	curve: -4);
Synth.scope(					// create a Synth to play the sound,
	{ 						// (open a sound function to be played)
		EnvGen.ar(				// create an EnvGen UGen at audio rate
							// with two arguments:
			env: e, 			// the envelope defined above,
			mul: Pulse.ar(		// and multiply the envelope signal with
							// a new kind of Oscillator with only one argument:
				freq: 300		// a frequency of 300 Hz. This lets the other arguments
			)				// (look them up!) fall back on their default values.
		)					// close the EnvGen's argument list.
	}						// close the sound function.
)							// close the Synth's argument list.
)
````

There are several syntactic variants for patching an EnvGen and a Ugen together.

Putting the Ugen into the mul input of the EnvGen:

````
EnvGen.ar(
	env: e,
	mul: Pulse.ar(freq: 300)
)
````

In this case, the type of EnvGen (ar or kr) determines whether the resulting signal is ar or kr; so for audio signals, use ar.

Multiplying the Ugen with the EnvGen:

    Pulse.ar(freq: 300) * EnvGen.ar(env: e);

This syntax is good for using Audio signals with kr envelopes, which are more efficient than ar envelopes:

    Pulse.ar(freq: 300) * EnvGen.kr(env: e);

You can also put the EnvGen into the mul input of a UGen:

````
Pulse.ar(
	freq: 300,
	mul: EnvGen.ar(env: e)
);
````

For a comparison of the efficiency of these variants, please see [5.7 CPU Load and Benchmarks].

So now that we can play one note, how can we make that note repeat?  Meet Spawn, one of the most powerful higher-level UGens.

Opening Spawn.help tells you that an Instance of Spawn expects this list of arguments:

    Spawn.ar(newEventFunc, numChannels, nextTime, maxRepeats, mul, add)

Here's how to put a Spawn into a Synth's sound function ( a.k.a. 'uGenGraphFunc'):

````
(
var env;
env = Env.perc(attack: 0.01,
	release: 1,
	level: 1,
	curve: -4);
Synth.play(					// create a Synth to play the sound,
	{					// (open a sound function to be played)
	Spawn.ar(			// make an instance of Spawn, which is a UGen at audio rate,
		{ 				// open newEventFunc, a function that generates a new event
						// every time spawn 'plays itself'. This function returns a patch of
						// UGens, a.k.a. a UGen graph, that will  be played by Synth.
						// The UGen graph  in this example is:
		Saw.ar(			// a sawtooth oscillator (look it up...) with only argument:
				freq: 300) 	// a frequency of 300 Hz.
		* EnvGen.kr(env, 		// An EnvGen with envelope e,
			 					// add one more argument for EnvGen:
			levelScale: 0.2			//  scale levels by 0.2 to make it softer. (look it up...)
			)			// close the EnvGen's argument list,
		},				// then close Spawn's newEventFunc,
						// and continue with Spawn's argument list:
		numChannels: 1, // numChannels = 1 audio channel,
		nextTime: 2, 		// nextTime = every 2 seconds.
		maxRepeats: 10	// maxRepeats = 10: stop after 10 events.
	)					// close Spawn's argument list.
	}					// close the Synth's first argument, i.e. the sound function,
)						// and close the Synth's argument list.
)
````

(Try rewriting this in positional style; Spawn is one of the reasons why I like keyword style!)

This sounds boring enough to give you time to watch the status line that appears at the top of the screen, right under the Menu bar. It gives you statistical readouts on the computing resources you are using for the running synthesis: CPU peak and average, i.e. how much of the processor's capacity you are using, the elapsed time since the synthesis started, the current Volume, and the number of currently running Ugens.

You can see how Spawn adds 3 UGens every two seconds and removes them when their sound is over. This is caused by the EnvGen, which knows when the envelope it uses is over, and lets the Spawn remove both itself and its UGen inputs (in this case just a lonely Saw oscillator).

While it is easy to hear how many Ugens are still running in this program, there are many Ugens that linger on inaudibly unless you take care to remove them.  They will use up CPU power and cause everything from synthesis dropouts to possible system crashes.

This is why it is indispensable to use EnvGen and Spawn to remove Ugens, see also [2.7 Removing Ugens].

Spawn has a lot more advanced functions, such as setting nextTime from inside the newEventFunc, or nesting Spawns inside Spawns; see Spawn.help for many more examples (highly recommended).

Now, to answer the first question, how would you play a sequence of notes in SC2?  While there is a special UGen designed to play scores in C-music style, it makes sense to put everything together here, using Spawn:

````
(
var env, freqs, times;
env = Env.perc(0.01, 2, 1, -2);
freqs = [ 250, 300, 450, 375, 281 ];	// make an Array of frequencies,
times = [ 2, 1.5, 1.2, 0.95, 0.7 ];	// and an Array of times.
Synth.scope({
	// tell Synth to stop when piece is over:
	thisSynth.sched(
		times.sum * 2, 			// after 2 repeats
		{ Synth.stop }
	);
	Spawn.ar(					// make an instance of Spawn,
		{ arg 					// declare arguments inside the newEventFunc:
		thisSpawn, 			// first argument is this instance of Spawn itself,
		eventCount;			// the number of each new event; first event is 0,
							// second is 1, etc.
		var freq, time;			// declare vars inside this function...
		freq = freqs.at(eventCount); 	// get freq and time for this event:
		time = times.at(eventCount);
		thisSpawn.nextTime = time;		// set the spawn's nextTime variable
									// to the value from the times list.
		EnvGen.ar(env,
			Saw.ar(freq),		// Saw with a frequencyfrom the list freqs.
			levelScale: 0.2		// add 0 signal offset, and scale levels by 0.2.
			)				// close the EnvGen's argument list,
		},					// then close Spawn's newEventFunc,
		1, 					// numChannels = 1 audio channel,
		nil, 					// nextTime = nil bescause it is defined inside newEventFunc.
		5					// maxRepeats = 5. What happens when you change it to 10?
	)						// close Spawn's argument list.
	}						// close the Synth's first argument, i.e. the sound function,
)							// and close the Synth's argument list.
)
````

If you try changing maxRepeats to 10, you will get a runtime error.  The problem is that freqs.at(eventCount) asks an array for the element at an index that does not exist.  You can fix this with freqs.wrapAt(eventCount) which makes the lists "wrap around".

Next: 	Try out what happens when the lists are not equal length.

The OrcScore UGen handles the same task at a higher level of abstraction; it lets you play an extended notelist format (similar to Cmusic) in SC2 (in realtime of course).  The abstraction hides the complexity from you and makes it look and feel quite easy; this ability to add a simple "front end" and go into the details behind it only as far as desired is one of the major strengths of OOP programming languages.

If you are interested in composing notelist scores right now, go through James McCartney's OrcScore help file and the examples, or go to [2.6 OrcScore - Using Notelists].  (You could then also look for uses of OrcScore with your text search utility...)

When you are ready for more programming basics, continue here: OrcScore requires you to write your instruments as an orchestra, which is "orchestra - a keyed collection of ugenGraphFunctions...."

You may remember that the first arg to Synth.play is always a function in curly brackets; the Synth help page refers to it as the ugenGraphFunction.  You already came across a lot of functions, so let's look at them more closely this time.

Next: [2.3 Sounds As Functions]
