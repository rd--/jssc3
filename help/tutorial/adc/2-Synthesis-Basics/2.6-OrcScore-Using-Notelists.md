# 2.6 OrcScore - Using Notelists

The OrcScore unit generator is essentially a wrapper around the Spawn object that lets you play scores in Csound style.  This means that it gives you a simple interface that hides some complex functionality; both for convenience and for clarity.

This is the first example from the help file with a lot of added documentation: (look at OrcScore.help first!)

````
(
// an orchestra and score player
e = Env.new([0,1,0.2,0],[0.004, 0.2, 1], -2);		// a simple envelope used by all instruments.
Synth.play(
	{	OrcScore.ar(
			// The Orchestra is an array of sound functions
			// (other Collections could be used too).
 //("ugenGraphFunc"):
	[
							// the first instrument:
		{ 	arg spawn, i, synth, 		// the three arguments that Spawn always
							// passes into a newEventFunction first,
			deltaTime, 			// the time between one event and the next,
			instrumentNum, 		// which instrument will play it (by number
							// in the orchestra array).
			note, 				// note the instrument will play,
			amp = 0.1;			// and its amplitude with a default value.
							// The first instrument synthesis UGen patch:
							// an FSinOsc with an envelope generator.
			EnvGen.ar(e, FSinOsc.ar(note.midicps, amp));
		},
							// the second instrument:
		{ 	arg spawn, i, synth,
			deltaTime, instrumentNum, note, amp = 0.1;
							// identical except for the LFPulse oscillator.
			EnvGen.ar(e, LFPulse.ar(note.midicps, 0.1, amp));
		},
							// the third instrument:
		{ 	arg spawn, i, synth,
							// no note or pitch argument for this one,
			deltaTime, instrumentNum, amp = 0.2;
							// because it uses a Noise oscillator:
			EnvGen.ar(e, BrownNoise.ar(amp));
		}
	],
	// The Score is an array of arrays.
			[	// deltaTime, instrumentNum, (note if applicable), amplitude.
				[0.1, 1, 60, 0.5],
				[0.1, 1, 62],			// amp defaults here...
				[0.1, 1, 64],
				[0.1, 1, 65],
				[0.0, 0, 67],			// deltaTime = 0 means simultaneously.
				[0.0, 0, 71],
				[0.0, 0, 74],
				[0.4, 0, 79],
				[0.0, 0, 69],
				[0.0, 0, 72],
				[0.0, 0, 76],
				[0.4, 0, 81],
				[0.2, 2, 0.5],
				[0.2, 2],			// just instrument number, amp defaults,
				[0.4, 2],
				[0.4, 2],
				[0.4, 2],
				[0.4, 2, 0.5],			// amp given here.
				[0.4, 2],
				[0.2, 2],
				[0.2, 2],
				[0.8, 2]
			],
		1, 			// OrcScore (and the Spawn inside it) returns one channel,
		nil, 			// no nextTime here, as this is handled by reading deltaTime
					// from the score,
		2			// and maxRepeats 2.
	)
}
)
)
````

You can also use the Dictionary class for the orchestra, and you can generate a random score: (This example is simply taken from OrcScore.help as is.)

````
(
// an orchestra and score player with a dictionary as orchestra instead of an array.
// the score is generated randomly and then repeated indefinitely
e = Env.new([0,1,0.2,0],[0.004, 0.2, 0.5], -2, 2);
Synth.play({
	OrcScore.ar(
		// the orchestra
		IdentityDictionary[
			// the right arrow operator -> defines an instance of Association
			'sine' -> { arg spawn, i, synth, deltaTime, instrumentNum, note, dur, amp, pan;
				synth.releaseTime = dur;
				Pan2.ar(EnvGen.ar(e, FSinOsc.ar(note.midicps), 0, amp), pan);
			},
			'pulse' -> { arg spawn, i, synth, deltaTime, instrumentNum, note, dur, amp, pan;
				synth.releaseTime = dur;
				Pan2.ar(EnvGen.ar(e, LFPulse.ar(note.midicps, 0.1), 0, amp), pan);
			},
			'noise' -> { arg spawn, i, synth, deltaTime, instrumentNum, amp, pan;
				synth.releaseTime = 0.0;
				Pan2.ar(EnvGen.ar(e, PinkNoise.ar, 0, amp), pan);
			}
		],
		// the score
		Array.fill(48, {
			[
				{ [[0.1, 0.2].choose, 'noise', 0.15.rand, 1.0.rand2] },
				{ [[0.1, 0.2].choose, 'pulse', 48+24.rand, 0.4.rand, 0.15.rand, 1.0.rand2] },
				{ [[0, 0.1, 0.2].choose, 'sine',  60+24.rand, 1.5.rand, 0.2.rand, 1.0.rand2] }
			].choose.value;
		}) ++ [[3, 'rest']], // append a few seconds of rest
	2, nil, nil)
})
)
````

Note that a score is not limited to fixed numbers, it may contain many legal SC2 expressions.  Here are some simple examples:

````
(
Synth.play({
	OrcScore.ar(
		// the orchestra
		[
			{ 	arg spawn, i, synth, deltaTime, instrumentNum, note, dur, amp, pan;
				synth.releaseTime = dur;
				Pan2.ar(
					EnvGen.ar(e,
						FSinOsc.ar(note.value.midicps),  // .value needed to evaluate random pitch.
						0,
						amp),
					pan.value				// .value needed to evaluate random pan function.
				);
			}
		],
		// the score is a four note loop:
		score:
		[	[ 	1,   0, { 50 + 8.rand }, 3, 0.1, SinOsc.kr(10.0.rand) ],
						// random pitch for each repetition,
			[ 	0.8, 0, { 55 + 10.rand }, 2, 0.1, SinOsc.kr(10.0.rand) ],
					 	// but same pan LFO speed.
			[ 	0.6, 0, 67, 1, 0.1, { SinOsc.kr(10.0.rand) } ],
						// random pan LFO speed for each repetition,
			[ 	0.5, 0, 70, 1, 0.1, { SinOsc.kr(10.0.rand) } ]
						// but constant pitch.
		].scramble, 									// scramble only randomizes score order once,
														// when patch is executed.
	numChannels: 2, 				// two channels for pannning,
	maxRepeats: nil )				// repeat indefinitely.
})
)
````

Next: [2.7 Removing Ugens]
