# 2.8 Wavetable Synthesis

Wavetables are a very useful form of having synthesis data calculated in advance in order to use them repeatedly.  SC has a rich palette of tools for editing wavetables.  The standard method for creating a wavetable for an audio osc is:

    *sineFill(size, amplitudes, phases)

Fill a Wavetable of the given size with a sum of sines at the given amplitudes and phases.  The Wavetable will be normalized.

- size - must be a power of 2.
- amplitudes - an Array of amplitudes for each harmonic beginning with the fundamental.
- phases - an Array of phases in radians for each harmonic beginning with the fundamental.

    Wavetable.sineFill(512, 1.0/[1,2,3,4,5,6]).plot;
    Wavetable.sineFill(512, [1]).plot;			// a simpler wavetable.
    Wavetable.sineFill(512, [1], [0.5pi]).plot;		// testing the phase parameter.

You can conveniently test-play Wavetables from their plot window by hitting the space bar.

Next, hit the edit button on the mixer; this lets you change the frequency of the wavetable test osc.

All the entries in the Fill and Alter menus apply to Wavetables, so try all of them.

They are all documented in the [Fill Menu] and [Alter Menu] help files.

The best one to start with is Fourier & Chebyshev:

The Fourier analysis of a table shows you the amplitudes and phases of the first 32 harmonics of this table. Changing amplitudes changes the sound of a table very intuitively: more higher harmonics make the sound brighter.

Changing the phases is more subtle: While the waveform can appear radically different, its sound will remain very similar. (The main difference you will notice is a change in volume: As a new table is always normalized to a maximum amplitude of 1, a combination of phases that produces just one spike will yield a less powerful signal than a table that has a more even distribution of several 'near-peaks'.

All the the other entries in the Fill and Alter Menus also do interesting and useful things with the currently selected table. Make sure you spend enough time experimenting with as many of them as possible.  Especially the Fill menu functions are quite complex, but this is time well spent for gaining a better understanding of the spectral composition of timbres, the building of fixed timbres with Fourier, Phase Modulation, Buzz, Chebyshev, and other methods.

You can also draw table waveforms directly with the mouse:

a. Command-clicking inside the table draws straight lines, Double-clicking ends the drawing.

b. Option-clicking draws an exponential interpolation.  (To see this, click around 1 and then at ca 0.1.  Clicking a positive value, then a negative cannot create an exponential interpolation, so this will default to a straight line.)

c. Control-clicking Draws a sinusoidal interpolation line.

Note that you can hit the maximize window icon (second from top right) to enlarge a tableview and make it return to its original size and position by clicking the same button again.

Drawing audio waveforms directly may not be very interesting, but drawing waveforms in order to use them as control sources is a very powerful way of setting up environments for experimentation with complex synthesis methods.  see [4.5 Tables As Controllers] for details on this.

See the [Oscillators] help page for an overview on which oscillators expect (one or more) tables to read its waveform from.

Here's a short example for the standard oscillator that uses a table:

````
var table1;
table1 = Wavetable.sineFill(512, 1.0/[1,2,3,4,5,6]);
table1.plot;
{ Osc.ar(table1, MouseX.kr(200, 1000, \exponential, 0.1), 0, 0.2) }.scope;
````

Finally, an example for COsc, a chorusing oscillator that uses a table: It reads through the table at two slightly different speeds, thus creating beats between the different frequencies.

````
var table1;
table1 = Wavetable.sineFill(512, 1.0/[1,2,3,4,5,6]);
table1.plot;
{ 	COsc.ar(table1,
		freq: MouseX.kr(200, 1000, \exponential, 0.1),
		beats: MouseY.kr(10, 0),
		mul: 0.2) }.scope;
````

Saving and Loading Tables is very easy too:

````
var table1;
table1 = Wavetable.sineFill(512, 1.0/[1,2,3,4,5,6]);
table1.putFile("Save my Table as:", "table1.wt");	// opens a Dialog that lets you save a table.
````

````
Wavetable.getFile({ arg ok, table; 			// lets you pick a wavetable file to load.
	if (ok, { table.plot; });				// plot the table if a file was picked.
})
````

If you know the path to your saved table, you can read it directly:

    var table = Wavetable.read("MyDisk:TablesFolder:myTable1");

## Wavetables and Signals

A different kind of pre-calculated audio data is the Signal Class.  While Wavetables have to have a size that is a power of two, Signals can be any size:

    Signal.newClear(123).fill(0.5).plot;
    Signal.sineFill(500, [1, 2]).plot;

If a Signal has a size that is a power of two, it can be converted to a Wavetable:

    s = Signal.sineFill(256, [1, 2]);
    s.plot;
    s.asWavetable.plot;

And Wavetables can be converted back to Signals too:

    t = Wavetable.sineFill(256, [1, 2]);
    t.plot;
    t.asSignal.plot;

The main difference is that Wavetables internally contain data that are prepared for efficient Oscillator interpolation, while a Signal contains the sample points as they are.

A typical use for Signals is the audio data contained in soundfiles:

````
var filename, sound, signal;
filename = ":Sounds:floating_1";
sound = SoundFile.new;
if (sound.read(filename), {
	signal = sound.data.at(0);
	"sound.data is an array of Signals: ".postc; sound.data.postln;
	"signal is a Signal: ".postc; signal.postln;
	Synth.play({ PlayBuf.ar(signal, sound.sampleRate, 1, 0, 0, signal.size-2) });
},{ (filename ++ " not found.\n").post });
````

See also PlayBuf.help, SoundFile.help, and [3.3 Extending A Sample Program].

A list of what oscillators use which kind of data (thanks to Mark Polishook):

- Osc -> Wavetable
- COsc -> Wavetable
- COsc2 -> Wavetable
- OscX4 -> Wavetable
- Shaper -> Wavetable

- PlayBuf -> Signal
- Osc1 -> Signal
- OscN -> Signal

## Exercises

Try modifying some of your modulation or subtractive patches to use wavetable oscillators.  Make sure you also try COsc2 and OscX4 .

Next: [3.1 Errors and Debugging]
