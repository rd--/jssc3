# 7.1 Try Unknown Combinations

The sheer scope of synthesis UGens implemented in SC2 and the generality of it lets you apply the exploratory programming style suggested in [3.1 Testing - Ask the System!] to sound synthesis itself.  James McCartney's example files have a lot of off-mainstream ideas that produce strange and beautiful sounds, so browse through those for ideas.

The following patches demonstrate some strategies for exploring the space of possibilities inSC2.

## 1. Check out all the combinations of two simple things

For example, a SinOsc and sample playback.  Note that the SinOsc frequencies are fixed here; so try different ones, and changing ones too!

Modulate the frequency of a SinOsc with a sample:

    var soundFile = SfAcquire("floating_1", 1, [1]).first;
    var sampleLoop = PlayBuf(1, soundFile, 0.5, 0, 0, 1, 0);
    SinOsc([100, 150] + (sampleLoop * MouseX(0, 1400, 0, 0.1)), 0) * MouseY(0.2, 0.0002, 0, 0.2)

Modulate frequency and amplitude of a SinOsc with a sample:

    var soundFile = SfAcquire("floating_1", 1, [1]).first;
    var sampleLoop = PlayBuf(1, soundFile, 0.5, 0, 0, 1, 0);
    var ampMod = (sampleLoop * MouseY(0, 1, 0, 0.2)) + MouseY(0, 1, 0, 0.2);
    SinOsc([100, 150] + (sampleLoop * MouseX(0, 1400, 0, 0.1)), 0) * ampMod * 0.2

Modulate phase and amplitude of a SinOsc with a sample:

    var soundFile = SfAcquire("floating_1", 1, [1]).first;
    var sampleLoop = PlayBuf(1, soundFile, 0.5, 0, 0, 1, 0);
    var ampMod = (sampleLoop * MouseY(0, 1, 0, 0.2)) + MouseY(0, 1, 0, 0.2);
    SinOsc([100, 149.8], sampleLoop * MouseX(0, 7, 0, 0.1)) * ampMod * 0.2

## 2. Use more unusual mathematical functions to modify signals.

Many of them are implemented as BinaryOpUGens, i.e. they can do the same operations on running signals as on simple numbers.  Take for instance the modulo function:

    FSinOsc(100, 0) * XLn(1, 300, 30) % 1 * 0.1

Again:

    (FSinOsc(MouseX(100, 1000, 0, 0.1), 0) * MouseY(0.4, 10, 1, 0.2) + 0.5) % 1 - 0.5 * 0.1

It may sound better with some filtering. Feel free to try that.

## 3. Use Ugens in unorthodox ways.

For example, the FFT (fast Fourier Transform UGen usually converts a time-domain signal (e.g. an oscillator output) into a frequency-domain signal (e.g. for fftScope like display). This spectral signal is often modified, the modified version is converted back to the time domain with the IFFT UGen (Inverse Fast Fourier Transform).  However, you can also generate a signal (e.g Dust) and plug it into an IFFT as if it were a spectral signal (which it is not).  From James McCartney's FFT examples file:

````
(
// direct fourier synthesis
// using Dust to generate spikes in the frequency domain.
var fftsize, window, cosineTable, out;
fftsize = 512;		// length of FFT buffer
window = Signal.hanningWindow(fftsize);		// make a signal analysis/synthesis window
cosineTable = Signal.fftCosTable(fftsize);		// make cosine table required for FFT
{
	// inverse transform
	out = IFFT.ar(fftsize, 0, cosineTable, nil, window, Dust2.ar(200, 30), 0);
	out.real
}.scope(fftsize/Synth.sampleRate);
)
````

Some controllers added by me:

````
(
// direct fourier synthesis
// using Dust to generate spikes in the frequency domain.
// mouse control added by AdC for tutorial.
{
	var fftsize, window, cosineTable, out, mouseX, mouseY, fakeSpectrum;
	fftsize = 512;		// length of FFT buffer; must be > block size!!
	mouseX = MouseX.kr(1, 1000, 'exponential');
	mouseY = MouseY.kr(30, 0.03, 'exponential');
	fakeSpectrum = Dust2.ar(mouseX, mouseY);
	window = Signal.welchWindow(fftsize);			// make a signal analysis/synthesis window
	cosineTable = Signal.fftCosTable(fftsize);		// make cosine table required for FFT
	// inverse transform
	out = IFFT.ar(fftsize, 0, cosineTable, nil, window, fakeSpectrum, 0);
	out.real
}.scope(0.01);
)
````

The following patch expands on this idea: It makes the spikes that create grains at random freqencies repeat more or less regularly at the same frequencies.  This is done by using a Comb filter with a delaytime close to the time at which the IFFT repeats its synthesis frames.

````
(
// adapted from 'more direct fourier synthesis strangeness'
// using Impulse to generate spikes in the frequency domain with a comb delay.
// try finding better ranges for the controllers.
// hook up a GUI item to everything that could be a useful controller.
{
	var fftsize, window, cosineTable, frameRepeatTime, fakeSpectrum, out;
	fftsize = 512;		// length of FFT buffer
	window = Signal.welchWindow(fftsize);		// make a signal analysis/synthesis window
	cosineTable = Signal.fftCosTable(fftsize);	// make cosine table required for FFT
	frameRepeatTime = fftsize/Synth.sampleRate;
	fakeSpectrum = CombL.ar(
			Impulse.ar(
				MouseX.kr(10,10000,'exponential'),
				8),
			maxdelaytime: frameRepeatTime * 1.5,
			delaytime: frameRepeatTime  * MouseY.kr(0.8, 1.2),
			mul: 3);
	// inverse transform
	out = IFFT.ar(fftsize, 0, cosineTable, nil, window, fakeSpectrum, 0);
	[ out.real, out.imag ]
}.scope(0.01);
)
````

## Exercises:

Browse the examples folder, and modify, extend and add controllers to anything that sounds interesting to you.  I recommend keeping all the intermediate steps, and documenting what you do as you go.

Next: [7.2 Sound Modeling - A Tabla]
