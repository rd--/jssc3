# 7.4 A String Model

Karplus-Strong synthesis (named after the inventors of the technique), is a well-known synthesis algorithm for modeling vibrating strings.

An exciter signal goes into a delay line; this exciter signal models e.g. a plucking motion that hits a string.  The string itself is modeled by a delay line: The energy of the excitation travels along the string and gets reflected and partially absorbed at the string's terminations.  The string length is modeled as the delay time.

The major advantage of this technique is its efficiency and simplicity; for musically interesting results, it needs sophisticated extensions.

(This program is loosely based on a string model that was discussed on the SC-list by Mikael Laurson and Iannis Zannos. )

Really simplistic Karplus-Strong synthesis:

````
var freq = 440;
var repeatFreq = 0.3;
var exciter = Decay(in: Impulse(freq: repeatFreq, phase: 0), decayTime: 0.01) * PinkNoise();
CombL(in: exciter, maxdelaytime: 0.1, delaytime: 1 / freq, decaytime: 3)
````

Note the DC offset in the signal. You can get rid of this very conveniently with LeakDC:

````
var freq = 440;
var repeatFreq = 0.3;
var exciter = Decay(Impulse(repeatFreq, 0), 0.01) * PinkNoise();
var string = CombL(exciter, 0.1, 1 / freq, 3);
[string, LeakDC(string, 0.995)]
````

An inherent problem in this method is getting precise frequencies.  Since the delaytime is 1/frequency, this delaytime will very often not be an integer number of samples (i.e. an integer multiple of timeOfOneSample, when timeOfOneSample = 1/Synth.samplingRate).  If you do not account for those fractional sample delay times, you get frequencies quantized in quite noticeable steps, especially as you go higher up.  CombN does not interpolate for between-the-cracks delay times.

````
var freq = MouseX(220, 1760, 1, 0.2);
var repeatFreq = 0.3;
var exciter = Decay(Impulse(repeatFreq, 0), 0.02) * PinkNoise();
CombN(exciter, 0.1, 1 / freq, 3)
````

CombN has another unnatural side effect: the high frequencies do not decay more quickly than the lows. At first sight, CombL seems to fix this problem:

````
var freq = MouseX(220, 1760, 1, 0.2);
var repeatFreq = 0.3;
var exciter = Decay(Impulse(repeatFreq, 0), 0.02) * PinkNoise();
CombL(exciter, 0.1, 1 / freq, 3)
````

But actually, CombL introduces its own set of quirks: Whenever a frequency is corresponds exactly to an integer number of samples, the high fequencies will not decay faster, and when a delaytime is right in the middle between two samples, they will decay very fast.

Basic Karplus-Strong, very small frequency range: note how sound quality of the decay changes drastically with minimal variations in frequency: All the way left is very bright, in the middle of the screen high frequencies decay much faster.


````
var freq = MouseX(220, 1760, 1, 0.2);
var delayTime = MouseX(1 / 100, 1 / (100 + 2), 0, 0.1);
var repeatFreq = 0.3;
var exciter = Decay(Impulse(repeatFreq, 0), 0.02) * PinkNoise();
CombL(exciter, 0.1, delayTime, 3)
````

A different implementation of the same patch lets you address these problems: With a buffer to read from and write to explicitly, the delay loop is accessible for filtering, which can really help make sounds more realistic.

````
var freq = 100;
var repeatFreq = 0.3;
var feedbackCoef = 0.997;
var buffer = BufAlloc(1, 48000 * 0.3).clearBuf;
var exciter = Decay(Impulse(0.2, 0), 0.02) * PinkNoise();
var filterFreq = MouseY(20000, 2000, 1, 0.2);
var delayedSignal = DelayTap(buffer, 1 / freq);
var filteredSignal = LPF(delayedSignal, filterFreq);
var mixedSignal = (filteredSignal * feedbackCoef) + exciter;
mixedSignal.mrg(DelayWrite(buffer, mixedSignal))
````

This implementation has some advantages and some drawbacks:

1. You can filter the feedback signal to simulate the frequency-dependent decay in real instruments, but the filtering introduces more delay time, which reduces the frequency and thus detunes the pitch.

2. If you raise the frequency, you may read from and write into the same buffer within one control period; this introduces strange artifacts.  Try it: for a frequency above Synth.sampleRate/thisSynth.blockSize, and you will be surprised; the Comb solution did not have that problem.

3. Note that feedbackCoef now controls the decayTime; the interesting range is between 0.95 and 0.9999, which is much less intutive than decayTime = 3 (seconds).

## Exercises:

Make an instrument that is a monophonic MIDInote controlled single string and that responds to multiple MIDI or gui controllers for sound character.

Try modeling an instrument body: It might be just a Klank with very short ringTimes, which is equivalent to broad resonant frequency bands.

How would a guitar body sound if you hit it at the bridge with a very thin metal stick? This is the closest real world equivalent to a unit impulse that comes to my mind, so if you can model that sound with an Impulse and a Klank, you are probably getting close.  (Why not record that sound, make an analysis of it, and model it from there?)

Try designing a physically impossible resonator (i.e. instrument body), e.g. an object that changes its size and thus its resonant frequencies constantly. (How does a string sound when you attach it to a drum skin?)

Try modeling the 'buzzing bridge' of a sitar or a tanpura. There are objects for waveshaping in SC2, so try finding those and learning about them on your own.

Next: [7.5 Tibetan Cymbals]
