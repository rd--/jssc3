# 8.1 Basic Schroeder Reverberator a la Moorer/Loy

This program implements a classical configurable reverberator that consists of a tapped delay line with up to 10 taps followed by a bank of up to 6 comb filters.  The sample configuration data is taken from Gareth Loy's "lprev" program that is part of the UCSD CARL software distribution (Moore and Loy 1983).

This is an update of Stephen Pope's SC1 implementation to SC2 by Alberto de Campo.

One minor extension: Allpass filters  for decorrelating the output channels are added.

Basic structure:

- Initialize the tap table for early reflections.
- Initialize comb filter data for reverb tail.
- Set global parameters, put the amplitudes of dry and wet sound into a reasonable basic balance.
- Generate input signal
- Create a multi-tap delay line, declare a delay buffer with 0.1 sec length
- Make the reverb input always mono!
- Write samples to the delay line
- Initialize tap output, then loop through the tap table.
- Get tap signals, scale by tap level and sum them up.
- Create an array of 6 combs, initializing combs output first.
- Get comb signals, scale by each comb's level and sum them up.
- Put the output through two parallel chains of allpass delays.
- Initialize daisy-chain variable
- Mix it all: direct sound scaled by balance, first reflections and (combs through) allpass filters

````
var input,			// audio input signal
	revMonoInput,		// reverb input must be mono for this version.
	buffer,			// a buffer for the early reflections delay line
	tapData,		// Early reflection tap data (times, levels)
	tapsOut, 		// sound output from the delay taps
	combData,	 	// Table of comb data (times, levels)
	combs,			// List of comb objects
	combsOut,		// their sound output
	allPassIo, 		// allPass chain sound input/output variable
	revTime,		// Global decay (time in seconds)
	revBalance,		// Dry/wet balance (ratio).
	tapScale,		// Tap amplitude scaling factor.
	combScale,		// Comb amplitude scaling factor.
	delayWriter;
tapData = [
	[0.0043,	0.841],
	[0.0215,	0.504],
	[0.0268,	0.379],
	[0.0298,	0.346],
	[0.0485,	0.272],
	[0.0572,	0.217],
	[0.0595,	0.192],
	[0.0708,	0.181],
	[0.0741,	0.142],
	[0.0797,	0.134]
];
combData = [
	[0.050,	0.46],
	[0.056,	0.48],
	[0.061,	0.50],
	[0.068,	0.52],
	[0.072,	0.53],
	[0.078,	0.55]
];
revTime = 3;
revBalance = 0.5;
tapScale = revBalance / tapData.size;
combScale = revBalance / combs.size;
input = 0.5.coin.ifTrue({
	Impulse(0.2, 2)
}, ifFalse: {
	Decay2(Impulse(0.2, 2), 0.001, 0.2) * PinkNoise()
});
buffer = BufAlloc(1, 48000 * 0.1).clearBuf;
revMonoInput = input.isKindOf(Array).ifTrue({
	input.sum / input.size
}, ifFalse:	{
	input
});
delayWriter = DelayWrite(buffer, revMonoInput);
tapsOut = 0;
tapData.do ({
	arg params;
	tapsOut = tapsOut + (DelayTap(buffer, params.first) * params.second);
});
combsOut = 0;
1.to(6).do({
	arg index;
	combsOut = combsOut + (
		CombC(
			revMonoInput + tapsOut, // tapsOut could be scaled
			0.1,
			combData.nth(index).first,
			revTime
		) * combData.nth(index).second
	)
});
allPassIo = combsOut;
4.timesRepeat({
	allPassIo = AllpassN(
		allPassIo,
		0.050,
		[0.050.rand, 0.050.rand],
		1
)});
[
	[ input * (1 - revBalance), input * (1 - revBalance)],
	((tapsOut + allPassIo) * revBalance)
].sum.mrg(delayWriter)
````

## Exercises:

Try recording this and comparing it to [8.5 Room IR Simulation].

How do you like the sound quality with a "natural" sound source?  Is it realistic? In a real-world reverberant environment the higher frequencies usually decay faster than lower frequencies; try implementing this here in a controllable way.

Much of the code here is not very efficient, and it is also not very SC-like: There are more efficient coding options for adding signals, e.g. using the add inputs. See [5.8 CPU Load and Benchmarks].  Try benchmarking the variants that come to mind.

There are also more elegant Collection methods, and the code could be written in much more self-documenting style.

Make a GUI that lets you tune this program for better sound quality.

What difference would it make to use specific values for the Allpass filter times, rather than random values?  How would you go about designing your own "magic numbers" for the parameters? Consult the literature, e.g. as given in the [References].  (Good, expertly fine-tuned magic numbers are what you pay for in expensive hardware reverb gear such as Lexicon, TC electronic etc.)

How do you like the balance between input and reverb signals here?  Do you have any ideas on how to improve that?

This program has quite a lot of text; consider rewriting it as a Class.  Start from the top down: How would you want to use it?  MLReverb.ar(in, firstRefspecs, combSpecs, allPassSpecs, revBalance, ...) ?  Or something different?

Write a few hypothetical help files to see what would make most sense, then implement the design solution you like best.

Next: [8.2 Binaural Spatial Hearing]
